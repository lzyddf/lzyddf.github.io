<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[base-N解析]]></title>
    <url>%2F2018%2F10%2F25%2Fbase-N%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、找到入口用OD打开，右键-中文搜索引擎-智能搜索，找到字符串”please input your flag:”，双击跟踪，往上找入口点（push ebp）,下断点 下面是整个程序的核心执行过程01051310 /$ 55 push ebp ; 入口 01051311 |. 8BEC mov ebp,esp 01051313 |. 83E4 F8 and esp,0xFFFFFFF8 01051316 |. 51 push ecx 01051317 |. 8B0D 70300501 mov ecx,dword ptr ds:[&lt;&amp;MSVCP140.std::co&gt; 0105131D |. BA DC310501 mov edx,第四题.010531DC ; please input your flag: 01051322 |. 53 push ebx 01051323 |. 56 push esi 01051324 |. 57 push edi 01051325 |. E8 36020000 call 第四题.01051560 0105132A |. 8B0D 64300501 mov ecx,dword ptr ds:[&lt;&amp;MSVCP140.std::ci&gt; 01051330 |. E8 6B040000 call 第四题.010517A0 01051335 |. B9 18500501 mov ecx,第四题.01055018 0105133A |. 8D51 01 lea edx,dword ptr ds:[ecx+0x1] 0105133D |. 0f1f00 nop dword ptr ds:[eax] 01051340 |&gt; 8A01 /mov al,byte ptr ds:[ecx] ; 这个循环用来计算长度 01051342 |. 41 |inc ecx 01051343 |. 84C0 |test al,al 01051345 |.^ 75 F9 \jnz short 第四题.01051340 01051347 |. 2BCA sub ecx,edx 01051349 |. 83F9 0A cmp ecx,0xA ; 这里是个坑 0105134C |. 7C 56 jl short 第四题.010513A4 0105134E |. B9 18500501 mov ecx,第四题.01055018 01051353 |. E8 A8FDFFFF call 第四题.01051100 01051358 |. B9 F4310501 mov ecx,第四题.010531F4 ; guvf_vf_n_snxr_synt 0105135D |. B8 18500501 mov eax,第四题.01055018 01051362 |&gt; 8A10 /mov dl,byte ptr ds:[eax] 01051364 |. 3A11 |cmp dl,byte ptr ds:[ecx] 01051366 |. 75 1A |jnz short 第四题.01051382 01051368 |. 84D2 |test dl,dl 0105136A |. 74 12 |je short 第四题.0105137E 0105136C |. 8A50 01 |mov dl,byte ptr ds:[eax+0x1] 0105136F |. 3A51 01 |cmp dl,byte ptr ds:[ecx+0x1] 01051372 |. 75 0E |jnz short 第四题.01051382 01051374 |. 83C0 02 |add eax,0x2 01051377 |. 83C1 02 |add ecx,0x2 0105137A |. 84D2 |test dl,dl 0105137C |.^ 75 E4 \jnz short 第四题.01051362 0105137E |&gt; 33C0 xor eax,eax 01051380 |. EB 05 jmp short 第四题.01051387 01051382 |&gt; 1BC0 sbb eax,eax 01051384 |. 83C8 01 or eax,0x1 01051387 |&gt; 85C0 test eax,eax 01051389 |. 75 19 jnz short 第四题.010513A4 0105138B |. 8B0D 70300501 mov ecx,dword ptr ds:[&lt;&amp;MSVCP140.std::co&gt; 01051391 |. BA 08320501 mov edx,第四题.01053208 ; try a little bit harder!\n 01051396 |. E8 C5010000 call 第四题.01051560 0105139B |. 33C0 xor eax,eax 0105139D |. 5F pop edi 0105139E |. 5E pop esi 0105139F |. 5B pop ebx 010513A0 |. 8BE5 mov esp,ebp 010513A2 |. 5D pop ebp 010513A3 |. C3 retn 010513A4 |&gt; E8 17FFFFFF call 第四题.010512C0 010513A9 |. BE 18500501 mov esi,第四题.01055018 010513AE |. 8D4E 01 lea ecx,dword ptr ds:[esi+0x1] 010513B1 |&gt; 8A06 /mov al,byte ptr ds:[esi] ; 这也是计算长度 010513B3 |. 46 |inc esi 010513B4 |. 84C0 |test al,al 010513B6 |.^ 75 F9 \jnz short 第四题.010513B1 010513B8 |. 2BF1 sub esi,ecx 010513BA |. 33FF xor edi,edi 010513BC |. 85F6 test esi,esi 010513BE |. 7E 22 jle short 第四题.010513E2 010513C0 |. BB A8500501 mov ebx,第四题.010550A8 010513C5 |&gt; 8BD6 /mov edx,esi ; 这个循环是核心算法了 010513C7 |. 8D8F 18500501 |lea ecx,dword ptr ds:[edi+0x1055018] 010513CD |. 53 |push ebx ; /Arg1 = 010550A8 ASCII &quot;TRmqTaoi&quot; 010513CE |. 2BD7 |sub edx,edi 010513D0 |. E8 9BFDFFFF |call 第四题.01051170 ; 核心算法就在里面，跟进去 010513D5 |. 83C7 05 |add edi,0x5 ; 出来后我们可以知道，每循环一次， 010513D8 |. 83C4 04 |add esp,0x4 ; 取5位输入，输出8个字符 010513DB |. 83C3 08 |add ebx,0x8 010513DE |. 3BFE |cmp edi,esi 010513E0 |.^ 7C E3 \jl short 第四题.010513C5 010513E2 |&gt; B9 24320501 mov ecx,第四题.01053224 ; usmgRa6FTekuNaomusmkN66eBZmkN7gcBN6kNaokammkPZwmuRmD==== 010513E7 |. B8 A8500501 mov eax,第四题.010550A8 ; ↑用来比较的字符串 010513EC |. 0f1f40 00 nop dword ptr ds:[eax] 010513F0 |&gt; 8A10 /mov dl,byte ptr ds:[eax] ; 这个循环就是比较过程，有一位不对就会跳到失败 010513F2 |. 3A11 |cmp dl,byte ptr ds:[ecx] 010513F4 |. 75 1A |jnz short 第四题.01051410 010513F6 |. 84D2 |test dl,dl 010513F8 |. 74 12 |je short 第四题.0105140C 010513FA |. 8A50 01 |mov dl,byte ptr ds:[eax+0x1] 010513FD |. 3A51 01 |cmp dl,byte ptr ds:[ecx+0x1] 01051400 |. 75 0E |jnz short 第四题.01051410 01051402 |. 83C0 02 |add eax,0x2 01051405 |. 83C1 02 |add ecx,0x2 01051408 |. 84D2 |test dl,dl 0105140A |.^ 75 E4 \jnz short 第四题.010513F0 0105140C |&gt; 33C0 xor eax,eax 0105140E |. EB 05 jmp short 第四题.01051415 01051410 |&gt; 1BC0 sbb eax,eax 01051412 |. 83C8 01 or eax,0x1 01051415 |&gt; 8B0D 70300501 mov ecx,dword ptr ds:[&lt;&amp;MSVCP140.std::co&gt; 0105141B |. BA 60320501 mov edx,第四题.01053260 ; Congratulations!!!\n 01051420 |. 85C0 test eax,eax 01051422 |. 74 05 je short 第四题.01051429 ; ；关键跳转 01051424 |. BA 74320501 mov edx,第四题.01053274 ; soooooooooorry\n 01051429 |&gt; E8 32010000 call 第四题.01051560 0105142E |. 68 84320501 push 第四题.01053284 ; /pause 01051433 |. FF15 F8300501 call dword ptr ds:[&lt;&amp;api-ms-win-crt-runt&gt;; \system 01051439 |. 83C4 04 add esp,0x4 0105143C |. 33C0 xor eax,eax 0105143E |. 5F pop edi 0105143F |. 5E pop esi 01051440 |. 5B pop ebx 01051441 |. 8BE5 mov esp,ebp 01051443 |. 5D pop ebp 01051444 \. C3 retn 2、简单分析运行，f8单步调试，不久便遇到第一个跳转点 01051349 |. 83F9 0A cmp ecx,0xA 0105134C |. 7C 56 jl short 第四题.010513A4 根据以前的经验，这里应该是判断用户名是否为10位，若不足10位则跳转到失败 于是一开始一直输入10位的用户名，发现不论怎么输入都不可能变成 usmgRa6FTekuNaomusmkN66eBZmkN7gcBN6kNaokammkPZwmuRmD==== 这时候在跳转语句下面看到一行字符串：guvf_vf_n_snxr_synt 下面有个循环，正是与这个字符串进行比较 01051362 |&gt; 8A10 /mov dl,byte ptr ds:[eax] 01051364 |. 3A11 |cmp dl,byte ptr ds:[ecx] 01051366 |. 75 1A |jnz short 第四题.01051382 01051368 |. 84D2 |test dl,dl 0105136A |. 74 12 |je short 第四题.0105137E 0105136C |. 8A50 01 |mov dl,byte ptr ds:[eax+0x1] 0105136F |. 3A51 01 |cmp dl,byte ptr ds:[ecx+0x1] 01051372 |. 75 0E |jnz short 第四题.01051382 01051374 |. 83C0 02 |add eax,0x2 01051377 |. 83C1 02 |add ecx,0x2 0105137A |. 84D2 |test dl,dl 0105137C |.^ 75 E4 \jnz short 第四题.01051362 尝试输入guvf_vf_n_snxr_synt，程序输出：this_is_a_fake_flag; 怀疑是rot_13，再尝试输入：this_is_a_fake_flag; yes,比较成功，在以为即将看到胜利的时候，程序输出： try a little bit harder!（再努力一点！） 好吧，果然没有这么简单 3、再做突破有了上面的经验，我们已经知道上面的跳转是个坑，实际上必须跳转才行 那么既然只有输入小于10位才能跳转，该怎么办 再看下面的循环，发现循环每比较一位，就会出现一个跳转，一开始以为是跳转到结束 仔细看，和上面那个跳转的地址是一样的 那我们就可以放心的输入大于等于10位的用户名，来到下面的核心算法 尝试输入123456789012345678901234567890，单步调试，来到核心算法 跟踪进入 4、核心算法01051170 /$ 55 push ebp ; 一个很长的算法，需要慢慢看 01051171 |. 8BEC mov ebp,esp 01051173 |. 0FB601 movzx eax,byte ptr ds:[ecx] 01051176 |. 53 push ebx 01051177 |. 56 push esi 01051178 |. 57 push edi 01051179 |. 8BDA mov ebx,edx 0105117B |. 99 cdq 0105117C |. 8BF8 mov edi,eax 0105117E |. 8BF2 mov esi,edx 01051180 |. 0FB641 01 movzx eax,byte ptr ds:[ecx+0x1] 01051184 |. 99 cdq 01051185 |. 0FA4FE 08 shld esi,edi,0x8 01051189 |. C1E7 08 shl edi,0x8 0105118C |. 03F8 add edi,eax 0105118E |. 0FB641 02 movzx eax,byte ptr ds:[ecx+0x2] 01051192 |. 13F2 adc esi,edx 01051194 |. 99 cdq 01051195 |. 0FA4FE 08 shld esi,edi,0x8 01051199 |. C1E7 08 shl edi,0x8 0105119C |. 03F8 add edi,eax 0105119E |. 0FB641 03 movzx eax,byte ptr ds:[ecx+0x3] 010511A2 |. 13F2 adc esi,edx 010511A4 |. 99 cdq 010511A5 |. 0FA4FE 08 shld esi,edi,0x8 010511A9 |. C1E7 08 shl edi,0x8 010511AC |. 03F8 add edi,eax 010511AE |. 0FB641 04 movzx eax,byte ptr ds:[ecx+0x4] 010511B2 |. 13F2 adc esi,edx 010511B4 |. 99 cdq 010511B5 |. 0FA4FE 08 shld esi,edi,0x8 010511B9 |. C1E7 08 shl edi,0x8 010511BC |. 03F8 add edi,eax 010511BE |. 8BCF mov ecx,edi 010511C0 |. 13F2 adc esi,edx 010511C2 |. 8B55 08 mov edx,[arg.1] 010511C5 |. 8BC6 mov eax,esi 010511C7 |. C1E8 03 shr eax,0x3 010511CA |. 0FB680 7C5005&gt;movzx eax,byte ptr ds:[eax+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 010511D1 |. 8802 mov byte ptr ds:[edx],al ; 第一次赋值 010511D3 |. 8BC6 mov eax,esi 010511D5 |. 0FACC1 1E shrd ecx,eax,0x1E 010511D9 |. C1E8 1E shr eax,0x1E 010511DC |. 83E1 1F and ecx,0x1F 010511DF |. 0FB681 7C5005&gt;movzx eax,byte ptr ds:[ecx+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 010511E6 |. 8BCF mov ecx,edi 010511E8 |. 8842 01 mov byte ptr ds:[edx+0x1],al ; 第二次赋值 010511EB |. 8BC6 mov eax,esi 010511ED |. 0FACC1 19 shrd ecx,eax,0x19 010511F1 |. C1E8 19 shr eax,0x19 010511F4 |. 83E1 1F and ecx,0x1F 010511F7 |. 0FB681 7C5005&gt;movzx eax,byte ptr ds:[ecx+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 010511FE |. 8BCF mov ecx,edi 01051200 |. 8842 02 mov byte ptr ds:[edx+0x2],al ; 第三次赋值 01051203 |. 8BC6 mov eax,esi 01051205 |. 0FACC1 14 shrd ecx,eax,0x14 01051209 |. C1E8 14 shr eax,0x14 0105120C |. 83E1 1F and ecx,0x1F 0105120F |. 0FB681 7C5005&gt;movzx eax,byte ptr ds:[ecx+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 01051216 |. 8BCF mov ecx,edi 01051218 |. 8842 03 mov byte ptr ds:[edx+0x3],al ; 第四次赋值 0105121B |. 8BC6 mov eax,esi 0105121D |. 0FACC1 0F shrd ecx,eax,0xF 01051221 |. C1E8 0F shr eax,0xF 01051224 |. 83E1 1F and ecx,0x1F 01051227 |. 0FB681 7C5005&gt;movzx eax,byte ptr ds:[ecx+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 0105122E |. 8BCF mov ecx,edi 01051230 |. 8842 04 mov byte ptr ds:[edx+0x4],al ; 第五次赋值 01051233 |. 8BC6 mov eax,esi 01051235 |. 0FACC1 0A shrd ecx,eax,0xA 01051239 |. C1E8 0A shr eax,0xA 0105123C |. 83E1 1F and ecx,0x1F 0105123F |. 0FB681 7C5005&gt;movzx eax,byte ptr ds:[ecx+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 01051246 |. 8842 05 mov byte ptr ds:[edx+0x5],al ; 第六次赋值 01051249 |. 8BC7 mov eax,edi 0105124B |. 0FACF0 05 shrd eax,esi,0x5 0105124F |. 83E0 1F and eax,0x1F 01051252 |. C1EE 05 shr esi,0x5 01051255 |. 83E7 1F and edi,0x1F 01051258 |. 0FB680 7C5005&gt;movzx eax,byte ptr ds:[eax+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 0105125F |. 8842 06 mov byte ptr ds:[edx+0x6],al ; 第七次赋值 01051262 |. 0FB687 7C5005&gt;movzx eax,byte ptr ds:[edi+0x105507C] ; ABCDEFGHIJKLMNOPQRSTUVWXYZ 01051269 |. 8842 07 mov byte ptr ds:[edx+0x7],al ; 第八次赋值 0105126C |. 83FB 05 cmp ebx,0x5 ; Switch (cases 1..4) 0105126F |. 7D 38 jge short 第四题.010512A9 01051271 |. 8D43 FF lea eax,dword ptr ds:[ebx-0x1] 01051274 |. 83F8 03 cmp eax,0x3 01051277 |. 77 30 ja short 第四题.010512A9 01051279 |. FF2485 B01205&gt;jmp dword ptr ds:[eax*4+0x10512B0] 01051280 |&gt; C642 07 3D mov byte ptr ds:[edx+0x7],0x3D ; Case 4 of switch 0105126C 01051284 |. 8BC2 mov eax,edx 01051286 |. 5F pop edi 01051287 |. 5E pop esi 01051288 |. 5B pop ebx 01051289 |. 5D pop ebp 0105128A |. C3 retn 0105128B |&gt; 66:C742 06 3D&gt;mov word ptr ds:[edx+0x6],0x3D3D ; Case 3 of switch 0105126C 01051291 |. 8BC2 mov eax,edx 01051293 |. C642 05 3D mov byte ptr ds:[edx+0x5],0x3D 01051297 |. 5F pop edi 01051298 |. 5E pop esi 01051299 |. 5B pop ebx 0105129A |. 5D pop ebp 0105129B |. C3 retn 0105129C |&gt; 66:C742 02 3D&gt;mov word ptr ds:[edx+0x2],0x3D3D ; Case 1 of switch 0105126C 010512A2 |&gt; C742 04 3D3D3&gt;mov dword ptr ds:[edx+0x4],0x3D3D3D3D ; Case 2 of switch 0105126C 010512A9 |&gt; 5F pop edi ; Default case of switch 0105126C 010512AA |. 5E pop esi 010512AB |. 8BC2 mov eax,edx 010512AD |. 5B pop ebx 010512AE |. 5D pop ebp 010512AF \. C3 retn 看着这么长的算法挺头痛的，没办法，只能用c语言边单步调试边翻译了 5、核心算法C语言#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ char name[100]={&apos;\0&apos;}; char s[]={&quot;NoPqRsTuVwXyZaBcDeFgHiJkLm567234&quot;}; char s2[]={&quot;usmgRa6FTekuNaomusmkN66eBZmkN7gcBN6kNaokammkPZwmuRmD====&quot;}; char psd[100]={&apos;\0&apos;}; int l,i,j=0; unsigned long long int x,x2,y,y2,z=0;//edi,eax,esi gets(name); l=strlen(name); for(i=0;i&lt;l;i+=5){ x=name[i]; y=name[i+1];// z*=256; z+=x/0x10000000; x*=256; x+=y; y=name[i+2];// z*=256; z+=x/0x10000000; x*=256; x+=y; y=name[i+3];// z*=256; z+=x/0x10000000; x*=256; x+=y; y=name[i+4];// z*=256; z+=x/0x10000000; x*=256; x+=y; x2=x/0x100000000; x%=0x100000000; y=x2; y/=8; psd[j]=s[y];// j++; y=x2; y2=x; int t=0; long long int num=x; do{ num/=2; t++; }while(num&gt;0); y2/=pow(2,0x1E); y2+=y*pow(2,32-0x1E); y/=pow(2,0x1E); y2&amp;=0x1F; psd[j]=s[y2];// j++; y2=x; y=x2; y2/=0x2000000; y2+=y*pow(2,32-0x19); y/=0x2000000; y2&amp;=0x1F; psd[j]=s[y2];// j++; y2=x; y=x2; y2/=pow(2,0x14); y2+=y*pow(2,t-0x14); y/=pow(2,0x14); y2&amp;=0x1F; psd[j]=s[y2];// j++; y2=x; y=x2; y2/=pow(2,0xF); y2+=y*pow(2,t-0xF); y/=pow(2,0xF); y2&amp;=0x1F; psd[j]=s[y2];// j++; y2=x; y=x2; y2/=pow(2,0xA); y2+=y*pow(2,t-0xA); y/=pow(2,0xA); y2&amp;=0x1F; psd[j]=s[y2];// j++; y=x; y/=32; y&amp;=0x1F; x2/=32; x&amp;=0x1F; psd[j]=s[y]; j++; psd[j]=s[x]; j++; } return 0; } 这里写的是正向的算法，并不能轻易推出结果，在这个基础上改一下，写个爆破机 6、爆破机#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ unsigned char name[100]={ 32,32,32,32,32,32,32,32, 32,32,32,32,32,32,32,32, 32,32,32,32,32,32,32,32, 32,32,32,32,32,32,32,32 }; char s[]={&quot;NoPqRsTuVwXyZaBcDeFgHiJkLm567234&quot;}; char s2[]={&quot;usmgRa6FTekuNaomusmkN66eBZmkN7gcBN6kNaokammkPZwmuRmD====&quot;}; char psd[100]={&apos;\0&apos;}; int l,i,j=0; unsigned long long int x,x2,y,y2,z=0;//edi,eax,esi while(1){ j=0; for(i=0;i&lt;35;i+=5){ x=name[i]; y=name[i+1];// z*=256; z+=x/0x10000000; x*=256; x+=y; y=name[i+2];// z*=256; z+=x/0x10000000; x*=256; x+=y; y=name[i+3];// z*=256; z+=x/0x10000000; x*=256; x+=y; y=name[i+4];// z*=256; z+=x/0x10000000; x*=256; x+=y; x2=x/0x100000000; x%=0x100000000; y=x2; y/=8; psd[j]=s[y];// if(psd[j]!=s2[j]){ name[i]++; if(name[i]&gt;126){ name[i]=32; } break; } j++; if(j&gt;=51){ break; } y=x2; y2=x; int t=0; long long int num=x; do{ num/=2; t++; }while(num&gt;0); y2/=pow(2,0x1E); y2+=y*pow(2,32-0x1E); y/=pow(2,0x1E); y2&amp;=0x1F; psd[j]=s[y2];// if(psd[j]!=s2[j]){ name[i+1]++; if(name[i+1]&gt;126){ name[i+1]=32; name[i]++; } break; } j++; if(j&gt;=51){ break; } y2=x; y=x2; y2/=pow(2,0x19); y2+=y*pow(2,t-0x19); y/=pow(2,0x19); y2&amp;=0x1F; psd[j]=s[y2];// if(psd[j]!=s2[j]){ name[i+1]++; if(name[i+1]&gt;126){ name[i+1]=32; name[i]++; } break; } j++; if(j&gt;=51){ break; } y2=x; y=x2; y2/=pow(2,0x14); y2+=y*pow(2,t-0x14); y/=pow(2,0x14); y2&amp;=0x1F; psd[j]=s[y2];// if(psd[j]!=s2[j]){ name[i+2]++; if(name[i+2]&gt;126){ name[i+2]=32; name[i+1]++; } break; } j++; if(j&gt;=51){ break; } y2=x; y=x2; y2/=pow(2,0xF); y2+=y*pow(2,t-0xF); y/=pow(2,0xF); y2&amp;=0x1F; psd[j]=s[y2];// if(psd[j]!=s2[j]){ name[i+3]++; if(name[i+3]&gt;126){ name[i+3]=32; name[i+2]++; } break; } j++; if(j&gt;=51){ break; } y2=x; y=x2; y2/=pow(2,0xA); y2+=y*pow(2,t-0xA); y/=pow(2,0xA); y2&amp;=0x1F; psd[j]=s[y2];// if(psd[j]!=s2[j]){ name[i+3]++; if(name[i+3]&gt;126){ name[i+3]=32; name[i+2]++; } break; } j++; if(j&gt;=51){ break; } y=x; y/=32; y&amp;=0x1F; x2/=32; x&amp;=0x1F; psd[j]=s[y]; if(psd[j]!=s2[j]){ name[i+4]++; if(name[i+4]&gt;126){ name[i+4]=32; name[i+3]++; } break; } j++; if(j&gt;=51){ break; } psd[j]=s[x]; if(psd[j]!=s2[j]){ name[i+4]++; if(name[i+4]&gt;126){ name[i+4]=32; name[i+3]++; } break; } j++; if(j&gt;=51){ break; } } if(i&gt;=35 || j&gt;=51){ break; } } printf(&quot;%s&quot;,name); system(&quot;pause&quot;); return 0; } 运行，输出结果：9s27r4np499spoqs3prop7p47nsq1992尝试输入给程序，单步调试，发现在进行最终比较的时候，字符串变成了：9f27e4ac499fcbdf3cebc7c47afd1992有了之前的经验，想必这也是rot-13，我们把这个输入却依然弹出错误框，排查是否有bug或原因稍微思考了下，想起调试爆破的时候，有时候用户名往上累加好几位，输出的结果都一样这时候大概有数了，是在最后四位等于1992的时候，最先出现正确结果，爆破的循环就自动结束了，我们把最后一位再往上累加试试看，果然，运气不错，最后四位改成1993的时候，弹出提示框:Congratulations!!!]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EasyEasy解析]]></title>
    <url>%2F2018%2F10%2F23%2FEasyEasy%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[OD打开右键-中文搜索引擎-智能搜索，找到error，双击跟踪，上拉，找到入口点（push ebp）,下断点 2、第一次加密f8单步调试，0037140E处有个函数，跟随进去，发现里面有两个循环 1、计算用户名长度，作为循环变量用户名长度固定为22位 00371717 |&gt; /8B55 F0 /mov edx,[local.4] 0037171A |. |8A02 |mov al,byte ptr ds:[edx] 0037171C |. |8845 FE |mov byte ptr ss:[ebp-0x2],al 0037171F |. |8345 F0 01 |add [local.4],0x1 00371723 |. |807D FE 00 |cmp byte ptr ss:[ebp-0x2],0x0 00371727 |.^\75 EE \jnz short EasyEasy.003717172、将用户名进行第一次加密 0037173A |&gt; /8B45 F4 /mov eax,[local.3] ; EasyEasy.00371110 0037173D |. |83C0 03 |add eax,0x3 ; 可以理解为用户名长度每次从左向右减少3位 00371740 |. |8945 F4 |mov [local.3],eax 00371743 |&gt; |8B4D F4 mov ecx,[local.3] ; EasyEasy.00371110 00371746 |. |3B4D EC |cmp ecx,[local.5] 00371749 |. |0F8D 95010000 |jge EasyEasy.003718E4 0037174F |. |8B55 08 |mov edx,[arg.1] 00371752 |. |0355 F4 |add edx,[local.3] ; EasyEasy.00371110 00371755 |. |0FB602 |movzx eax,byte ptr ds:[edx] ; 取循环的第3*n次循环位16进制ascii码 00371758 |. |C1F8 02 |sar eax,0x2 0037175B |. |83E0 3F |and eax,0x3F 0037175E |. |8845 FF |mov byte ptr ss:[ebp-0x1],al 00371761 |. |0FB64D FF |movzx ecx,byte ptr ss:[ebp-0x1] ; 计算结果储存在ecx里 00371765 |. |8B55 0C |mov edx,[arg.2] 00371768 |. |0355 F8 |add edx,[local.2] 0037176B |. |A1 E0403700 |mov eax,dword ptr ds:[0x3740E0] ; R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U 00371770 |. |8A0C08 |mov cl,byte ptr ds:[eax+ecx] ; 第一次赋值 00371773 |. |880A |mov byte ptr ds:[edx],cl ; 获得加密用字符串的第ecx位，保存 00371775 |. |8B55 F8 |mov edx,[local.2] 00371778 |. |83C2 01 |add edx,0x1 0037177B |. |8955 F8 |mov [local.2],edx 0037177E |. |8B45 08 |mov eax,[arg.1] 00371781 |. |0345 F4 |add eax,[local.3] ; EasyEasy.00371110 00371784 |. |0FB608 |movzx ecx,byte ptr ds:[eax] ; 前两次取的值一样 00371787 |. |C1E1 04 |shl ecx,0x4 0037178A |. |83E1 30 |and ecx,0x30 0037178D |. |884D FF |mov byte ptr ss:[ebp-0x1],cl 00371790 |. |8B55 F4 |mov edx,[local.3] ; EasyEasy.00371110 00371793 |. |83C2 01 |add edx,0x1 ; 保存edx待用 00371796 |. |3B55 EC |cmp edx,[local.5] 00371799 |. |7D 39 |jge short EasyEasy.003717D4 ; 为最后一位则跳转 0037179B |. |8B45 08 |mov eax,[arg.1] 0037179E |. |0345 F4 |add eax,[local.3] ; EasyEasy.00371110 003717A1 |. |0FB648 01 |movzx ecx,byte ptr ds:[eax+0x1] ; 取循环的第3*n+1位循环位16进制ascii码 003717A5 |. |C1F9 04 |sar ecx,0x4 003717A8 |. |83E1 0F |and ecx,0xF 003717AB |. |0FB655 FF |movzx edx,byte ptr ss:[ebp-0x1] 003717AF |. |0BD1 |or edx,ecx 003717B1 |. |8855 FF |mov byte ptr ss:[ebp-0x1],dl 003717B4 |. |0FB645 FF |movzx eax,byte ptr ss:[ebp-0x1] 003717B8 |. |8B4D 0C |mov ecx,[arg.2] 003717BB |. |034D F8 |add ecx,[local.2] 003717BE |. |8B15 E0403700 |mov edx,dword ptr ds:[0x3740E0] ; R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U 003717C4 |. |8A0402 |mov al,byte ptr ds:[edx+eax] ; 第二次赋值 003717C7 |. |8801 |mov byte ptr ds:[ecx],al 003717C9 |. |8B4D F8 |mov ecx,[local.2] 003717CC |. |83C1 01 |add ecx,0x1 003717CF |. |894D F8 |mov [local.2],ecx 003717D2 |. |EB 51 |jmp short EasyEasy.00371825 003717D4 |&gt; |0FB655 FF |movzx edx,byte ptr ss:[ebp-0x1] 003717D8 |. |8B45 0C |mov eax,[arg.2] 003717DB |. |0345 F8 |add eax,[local.2] 003717DE |. |8B0D E0403700 |mov ecx,dword ptr ds:[0x3740E0] ; R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U 003717E4 |. |8A1411 |mov dl,byte ptr ds:[ecx+edx] 003717E7 |. |8810 |mov byte ptr ds:[eax],dl ; 给第30位赋值 003717E9 |. |8B45 F8 |mov eax,[local.2] 003717EC |. |83C0 01 |add eax,0x1 003717EF |. |8945 F8 |mov [local.2],eax 003717F2 |. |8B4D 0C |mov ecx,[arg.2] 003717F5 |. |034D F8 |add ecx,[local.2] 003717F8 |. |8A15 60313700 |mov dl,byte ptr ds:[0x373160] ; @ 003717FE |. |8811 |mov byte ptr ds:[ecx],dl ; 给第31位赋值 00371800 |. |8B45 F8 |mov eax,[local.2] 00371803 |. |83C0 01 |add eax,0x1 00371806 |. |8945 F8 |mov [local.2],eax 00371809 |. |8B4D 0C |mov ecx,[arg.2] 0037180C |. |034D F8 |add ecx,[local.2] 0037180F |. |8A15 60313700 |mov dl,byte ptr ds:[0x373160] ; @ 00371815 |. |8811 |mov byte ptr ds:[ecx],dl ; 给第32位赋值 00371817 |. |8B45 F8 |mov eax,[local.2] 0037181A |. |83C0 01 |add eax,0x1 0037181D |. |8945 F8 |mov [local.2],eax 00371820 |. |E9 BF000000 |jmp EasyEasy.003718E4 00371825 |&gt; |8B4D 08 |mov ecx,[arg.1] 00371828 |. |034D F4 |add ecx,[local.3] ; EasyEasy.00371110 0037182B |. |0FB651 01 |movzx edx,byte ptr ds:[ecx+0x1] ; 取循环的第3*n+1位循环位16进制ascii码 0037182F |. |C1E2 02 |shl edx,0x2 00371832 |. |83E2 3C |and edx,0x3C 00371835 |. |8855 FF |mov byte ptr ss:[ebp-0x1],dl 00371838 |. |8B45 F4 |mov eax,[local.3] ; EasyEasy.00371110 0037183B |. |83C0 02 |add eax,0x2 0037183E |. |3B45 EC |cmp eax,[local.5] 00371841 |. |7D 66 |jge short EasyEasy.003718A9 00371843 |. |8B4D 08 |mov ecx,[arg.1] 00371846 |. |034D F4 |add ecx,[local.3] ; EasyEasy.00371110 00371849 |. |0FB651 02 |movzx edx,byte ptr ds:[ecx+0x2] ; 取循环的第3*n+2位循环位16进制ascii码 0037184D |. |C1FA 06 |sar edx,0x6 00371850 |. |83E2 03 |and edx,0x3 00371853 |. |0FB645 FF |movzx eax,byte ptr ss:[ebp-0x1] 00371857 |. |0BC2 |or eax,edx 00371859 |. |8845 FF |mov byte ptr ss:[ebp-0x1],al 0037185C |. |0FB64D FF |movzx ecx,byte ptr ss:[ebp-0x1] 00371860 |. |8B55 0C |mov edx,[arg.2] 00371863 |. |0355 F8 |add edx,[local.2] 00371866 |. |A1 E0403700 |mov eax,dword ptr ds:[0x3740E0] ; R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U 0037186B |. |8A0C08 |mov cl,byte ptr ds:[eax+ecx] ; 第三次赋值 0037186E |. |880A |mov byte ptr ds:[edx],cl 00371870 |. |8B55 F8 |mov edx,[local.2] 00371873 |. |83C2 01 |add edx,0x1 00371876 |. |8955 F8 |mov [local.2],edx 00371879 |. |8B45 08 |mov eax,[arg.1] 0037187C |. |0345 F4 |add eax,[local.3] ; EasyEasy.00371110 0037187F |. |0FB648 02 |movzx ecx,byte ptr ds:[eax+0x2] ; 取循环的第3*n+2位循环位16进制ascii码 00371883 |. |83E1 3F |and ecx,0x3F 00371886 |. |884D FF |mov byte ptr ss:[ebp-0x1],cl 00371889 |. |0FB655 FF |movzx edx,byte ptr ss:[ebp-0x1] 0037188D |. |8B45 0C |mov eax,[arg.2] 00371890 |. |0345 F8 |add eax,[local.2] 00371893 |. |8B0D E0403700 |mov ecx,dword ptr ds:[0x3740E0] ; R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U 00371899 |. |8A1411 |mov dl,byte ptr ds:[ecx+edx] ; 第四次赋值 0037189C |. |8810 |mov byte ptr ds:[eax],dl 0037189E |. |8B45 F8 |mov eax,[local.2] 003718A1 |. |83C0 01 |add eax,0x1 003718A4 |. |8945 F8 |mov [local.2],eax 003718A7 |. |EB 36 |jmp short EasyEasy.003718DF 003718A9 |&gt; |0FB64D FF |movzx ecx,byte ptr ss:[ebp-0x1] 003718AD |. |8B55 0C |mov edx,[arg.2] 003718B0 |. |0355 F8 |add edx,[local.2] 003718B3 |. |A1 E0403700 |mov eax,dword ptr ds:[0x3740E0] ; R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U 003718B8 |. |8A0C08 |mov cl,byte ptr ds:[eax+ecx] 003718BB |. |880A |mov byte ptr ds:[edx],cl ; 给第31位赋值 003718BD |. |8B55 F8 |mov edx,[local.2] 003718C0 |. |83C2 01 |add edx,0x1 003718C3 |. |8955 F8 |mov [local.2],edx 003718C6 |. |8B45 0C |mov eax,[arg.2] 003718C9 |. |0345 F8 |add eax,[local.2] 003718CC |. |8A0D 60313700 |mov cl,byte ptr ds:[0x373160] ; @ 003718D2 |. |8808 |mov byte ptr ds:[eax],cl ; 给第32位赋值 003718D4 |. |8B55 F8 |mov edx,[local.2] 003718D7 |. |83C2 01 |add edx,0x1 003718DA |. |8955 F8 |mov [local.2],edx 003718DD |. |EB 05 |jmp short EasyEasy.003718E4 003718DF |&gt;^\E9 56FEFFFF \jmp EasyEasy.0037173A 3、第二次加密从call中出来，发现下面定义了一堆字符，往下还有一个循环，是第二次加密 003715F6 |&gt; /8B85 50FFFFFF /mov eax,[local.44] ; local.44为循环变量 003715FC |. |83C0 01 |add eax,0x1 003715FF |. |8985 50FFFFFF |mov [local.44],eax 00371605 |&gt; |83BD 50FFFFFF&gt; cmp [local.44],0x20 0037160C |. |0F8D 90000000 |jge EasyEasy.003716A2 ; 循环到第33次跳出 00371612 |. |8B8D 50FFFFFF |mov ecx,[local.44] 00371618 |. |0FBE940D 54FF&gt;|movsx edx,byte ptr ss:[ebp+ecx-0xAC] ; 取第一次加密后的第一位 00371620 |. |8B85 50FFFFFF |mov eax,[local.44] 00371626 |. |0FBE8C05 10FF&gt;|movsx ecx,byte ptr ss:[ebp+eax-0xF0] ; 用来加密的字符串1 0037162E |. |33D1 |xor edx,ecx 00371630 |. |8B85 50FFFFFF |mov eax,[local.44] 00371636 |. |885405 D4 |mov byte ptr ss:[ebp+eax-0x2C],dl 0037163A |. |8B8D 50FFFFFF |mov ecx,[local.44] 00371640 |. |81E1 01000080 |and ecx,0x80000001 00371646 |. |79 05 |jns short EasyEasy.0037164D ; 大于等于0则跳转 00371648 |. |49 |dec ecx 00371649 |. |83C9 FE |or ecx,0xFFFFFFFE 0037164C |. |41 |inc ecx 0037164D |&gt; |85C9 |test ecx,ecx 0037164F |. |75 27 |jnz short EasyEasy.00371678 00371651 |. |8B95 50FFFFFF |mov edx,[local.44] 00371657 |. |0FBE8415 30FF&gt;|movsx eax,byte ptr ss:[ebp+edx-0xD0] ; 用来加密的字符串2 0037165F |. |8B8D 50FFFFFF |mov ecx,[local.44] 00371665 |. |0FBE540D D4 |movsx edx,byte ptr ss:[ebp+ecx-0x2C] 0037166A |. |2BD0 |sub edx,eax 0037166C |. |8B85 50FFFFFF |mov eax,[local.44] 00371672 |. |885405 D4 |mov byte ptr ss:[ebp+eax-0x2C],dl 00371676 |. |EB 25 |jmp short EasyEasy.0037169D 00371678 |&gt; |8B8D 50FFFFFF |mov ecx,[local.44] 0037167E |. |0FBE940D 30FF&gt;|movsx edx,byte ptr ss:[ebp+ecx-0xD0] 00371686 |. |8B85 50FFFFFF |mov eax,[local.44] 0037168C |. |0FBE4C05 D4 |movsx ecx,byte ptr ss:[ebp+eax-0x2C] 00371691 |. |03CA |add ecx,edx 00371693 |. |8B95 50FFFFFF |mov edx,[local.44] 00371699 |. |884C15 D4 |mov byte ptr ss:[ebp+edx-0x2C],cl 0037169D |&gt;^\E9 54FFFFFF \jmp EasyEasy.003715F6 发现用来加密的字符串就是上面定义的一堆字符 4、关键跳转003716A2 |&gt; \8D45 D4 lea eax,[local.11] 003716A5 |. 50 push eax ; /Arg1 = 00000020 003716A6 |. E8 55020000 call EasyEasy.00371900 ; \EasyEasy.00371900 003716AB |. 83C4 04 add esp,0x4 003716AE |. 83F8 01 cmp eax,0x1 003716B1 |. 75 16 jnz short EasyEasy.003716C9 ;关键跳转 003716B3 |. 6A 40 push 0x40 ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL 003716B5 |. 68 A8403700 push EasyEasy.003740A8 ; |Success 003716BA |. 68 B0403700 push EasyEasy.003740B0 ; |Congratulations! 003716BF |. 6A 00 push 0x0 ; |hOwner = NULL 003716C1 |. FF15 D0303700 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \MessageBoxA 003716C7 |. EB 14 jmp short EasyEasy.003716DD 003716C9 |&gt; 6A 40 push 0x40 ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL 003716CB |. 68 C4403700 push EasyEasy.003740C4 ; |Erros 003716D0 |. 68 CC403700 push EasyEasy.003740CC ; |Failed! 003716D5 |. 6A 00 push 0x0 ; |hOwner = NULL 003716D7 |. FF15 D0303700 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \MessageBoxA 上面的call EasyEasy.00371900会改变eax的值，跟进去看看 5、结果比较出现了第三个循环，是用来与正确flag得出的结果进行比较用的 0037199D |&gt; /8B45 FC /mov eax,[local.1] 003719A0 |. |83C0 01 |add eax,0x1 003719A3 |. |8945 FC |mov [local.1],eax 003719A6 |&gt; |837D FC 20 cmp [local.1],0x20 003719AA |. |7D 20 |jge short EasyEasy.003719CC 003719AC |. |8B4D 08 |mov ecx,[arg.1] 003719AF |. |034D FC |add ecx,[local.1] 003719B2 |. |0FBE11 |movsx edx,byte ptr ds:[ecx] 003719B5 |. |8B45 FC |mov eax,[local.1] 003719B8 |. |0FBE4C05 D8 |movsx ecx,byte ptr ss:[ebp+eax-0x28] 003719BD |. |3BD1 |cmp edx,ecx ; 关键比较 003719BF |. |74 09 |je short EasyEasy.003719CA 003719C1 |. |C745 F8 00000&gt;|mov [local.2],0x0 003719C8 |. |EB 02 |jmp short EasyEasy.003719CC 003719CA |&gt;^\EB D1 \jmp short EasyEasy.0037199D 6、将前两个加密算法写成c语言#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ char name[100]={&apos;\0&apos;};//待输入的用户名 char s[]={&quot;R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U&quot;};// 第一次加密用的字符串 char s2[100]={&apos;\0&apos;};//存放第一次加密后的结果 //第二次加密用的字符串1 char s3[]={ 0x6D,0x6C,0x3A,0x7A,0x1D,0x4F,0x8A,0x7F, 0xB8,0x4A,0x57,0x13,0x2F,0xA7,0x63,0xBA, 0xC5,0xAA,0x65,0x99,0xDF,0x58,0xF5,0x54, 0x46,0xAB,0xB2,0xA0,0x31,0xC0,0xEB,0x38 }; //第二次加密用的字符串2 char s4[]={ 0x57,0x4D,0x4E,0x5E,0x4B,0x5A,0x51,0x55, 0x5D,0x5E,0x5F,0x51,0x5C,0x4D,0x58,0x5F, 0x57,0x54,0x5D,0x58,0x59,0x59,0x58,0x5F, 0x5B,0x58,0x5F,0x5B,0x5D,0x4C,0x52,0x5F }; char s5[100]={&apos;\0&apos;};//存放第二次加密后的结果 char s6[]={ 0xEF,0x68,0x14,0x68,0xEB,0x91,0x74,0x83, 0x77,0x6A,0xC2,0xA2,0xA8,0x41,0xDC,0x30, 0x54,0x4D,0xAE,0x30,0x2F,0xC2,0x41,0x75, 0xCD,0x34,0x7F,0x33,0xF3,0xE0,0x59,0xD7 }; int l,i,i2,j=0;//l计算用户名长度，i为循环变量,i2暂存i，j每次赋值后加一 unsigned int x,y; gets(name); fflush(stdin); l=strlen(name); //第一次循环 for(i=0;i&lt;l;i+=3){ i2=i; if(i2&gt;=l){ break; } x=name[i]; x/=4; x&amp;=0x3F; s2[j]=s[x]; j++; x=name[i]; x*=16; x&amp;=0x30; i2=i+1; if(i2&gt;=l){ s2[j]=s[x]; j++; s2[j]=&apos;@&apos;; j++; s2[j]=&apos;@&apos;; j++; break; } y=name[i+1]; y/=16; y&amp;=0xF; y|=x; s2[j]=s[y]; j++; x=name[i+1]; x*=4; x&amp;=0x3C; i2=i+2; if(i2&gt;=l){ s2[j]=s[x]; j++; s2[j]=&apos;@&apos;; j++; break; } y=name[i+2]; y/=64; y&amp;=3; y|=x; s2[j]=s[y]; j++; x=name[i+2]; x&amp;=0x3F; s2[j]=s[x]; j++; } //第二次循环 for(i=0;i&lt;0x20;i++){ x=s2[i]; y=s3[i]; x^=y; y=x; s5[i]=x; i2=i; i2&amp;=0x80000001; if(i2&gt;=0){ if(i2==0){ x=s4[i]; y-=x; s5[i]=y; }else{ x=s4[i]; y+=x; s5[i]=y; } } } printf(&quot;最终字符串：%s\n&quot;,s5); printf(&quot;拆分成一个个字符：&quot;); for(i=0;i&lt;32;i++){ printf(&quot;%c&quot;,s5[i]); } system(&quot;pause&quot;); return 0; } 发现这样不能推出flag，我们先将第二个循环逆着写一遍，输入正确结果，算出第一次加密后的字符串 7、逆算法#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ char name[100]={&apos;\0&apos;};//待输入的用户名 char s[]={&quot;R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U&quot;};// 第一次加密用的字符串 char s2[100]={&apos;\0&apos;};//存放第一次加密后的结果 //第二次加密用的字符串1 char s3[]={ 0x6D,0x6C,0x3A,0x7A,0x1D,0x4F,0x8A,0x7F, 0xB8,0x4A,0x57,0x13,0x2F,0xA7,0x63,0xBA, 0xC5,0xAA,0x65,0x99,0xDF,0x58,0xF5,0x54, 0x46,0xAB,0xB2,0xA0,0x31,0xC0,0xEB,0x38 }; //第二次加密用的字符串2 char s4[]={ 0x57,0x4D,0x4E,0x5E,0x4B,0x5A,0x51,0x55, 0x5D,0x5E,0x5F,0x51,0x5C,0x4D,0x58,0x5F, 0x57,0x54,0x5D,0x58,0x59,0x59,0x58,0x5F, 0x5B,0x58,0x5F,0x5B,0x5D,0x4C,0x52,0x5F }; char s5[]={ 0xEF,0x68,0x14,0x68,0xEB,0x91,0x74,0x83, 0x77,0x6A,0xC2,0xA2,0xA8,0x41,0xDC,0x30, 0x54,0x4D,0xAE,0x30,0x2F,0xC2,0x41,0x75, 0xCD,0x34,0x7F,0x33,0xF3,0xE0,0x59,0xD7 };//存放第二次加密后的结果 char s6[]={ 0xEF,0x68,0x14,0x68,0xEB,0x91,0x74,0x83, 0x77,0x6A,0xC2,0xA2,0xA8,0x41,0xDC,0x30, 0x54,0x4D,0xAE,0x30,0x2F,0xC2,0x41,0x75, 0xCD,0x34,0x7F,0x33,0xF3,0xE0,0x59,0xD7 }; int l,i,i2,j=0;//l计算用户名长度，i为循环变量,i2暂存i，j每次赋值后加一 unsigned int x,y; //第二次循环 for(i=0;i&lt;0x20;i++){ y=s5[i]; x=s4[i]; i2=i; i2&amp;=0x80000001; if(i2&gt;=0){ if(i2==0){ y+=x; }else{ y-=x; } } x=y; y=s3[i]; x^=y; s2[i]=x; } printf(&quot;最终字符串：%s\n&quot;,s2); system(&quot;pause&quot;); return 0; } 运行，得到字符串”+wXp+xOQlFvB+SWknSnAW1lBnwlxaT@@” 8、对第一个循环进行爆破#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(){ char name[100]={ &apos;f&apos;,&apos;l&apos;,&apos;a&apos;,&apos;g&apos;,&apos;{&apos;,32,32,32, 32,32,32,32,32,32,32,32, 32,32,32,32,32,&apos;}&apos; };//待输入的用户名 char s[]={&quot;R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U&quot;};// 第一次加密用的字符串 char s2[100]={&apos;\0&apos;};//存放第一次加密后的结果 //第二次加密用的字符串1 char s3[]={ 0x6D,0x6C,0x3A,0x7A,0x1D,0x4F,0x8A,0x7F, 0xB8,0x4A,0x57,0x13,0x2F,0xA7,0x63,0xBA, 0xC5,0xAA,0x65,0x99,0xDF,0x58,0xF5,0x54, 0x46,0xAB,0xB2,0xA0,0x31,0xC0,0xEB,0x38 }; //第二次加密用的字符串2 char s4[]={ 0x57,0x4D,0x4E,0x5E,0x4B,0x5A,0x51,0x55, 0x5D,0x5E,0x5F,0x51,0x5C,0x4D,0x58,0x5F, 0x57,0x54,0x5D,0x58,0x59,0x59,0x58,0x5F, 0x5B,0x58,0x5F,0x5B,0x5D,0x4C,0x52,0x5F }; char s5[]={&quot;+wXp+xOQlFvB+SWknSnAW1lBnwlxaT@@&quot;};//存放第二次加密后的结果 char s6[]={ 0xEF,0x68,0x14,0x68,0xEB,0x91,0x74,0x83, 0x77,0x6A,0xC2,0xA2,0xA8,0x41,0xDC,0x30, 0x54,0x4D,0xAE,0x30,0x2F,0xC2,0x41,0x75, 0xCD,0x34,0x7F,0x33,0xF3,0xE0,0x59,0xD7 }; int l,i,i2,j=0;//l计算用户名长度，i为循环变量,i2暂存i，j每次赋值后加一 unsigned int x,y; fflush(stdin); l=strlen(name); //第一次循环 while(1){ j=0; for(i=0;i&lt;22;i+=3){ i2=i; if(i2&gt;=22){ break; } x=name[i]; x/=4; x&amp;=0x3F; s2[j]=s[x]; if(s2[j]!=s5[j]){ name[i]++; if(name[i]&gt;126){ name[i-1]++; } break; } j++; x=name[i]; x*=16; x&amp;=0x30; i2=i+1; if(i2&gt;=22){ s2[j]=s[x]; j++; s2[j]=&apos;@&apos;; j++; s2[j]=&apos;@&apos;; j++; break; } y=name[i+1]; y/=16; y&amp;=0xF; y|=x; s2[j]=s[y]; if(s2[j]!=s5[j]){ name[i+1]++; if(name[i+1]&gt;126){ name[i]++; name[i+1]=32; } break; } j++; x=name[i+1]; x*=4; x&amp;=0x3C; i2=i+2; if(i2&gt;=22){ s2[j]=s[x]; j++; s2[j]=&apos;@&apos;; j++; break; } y=name[i+2]; y/=64; y&amp;=3; y|=x; s2[j]=s[y]; if(s2[j]!=s5[j]){ name[i+2]++; if(name[i+2]&gt;126){ name[i+1]++; name[i+2]=32; } break; } j++; x=name[i+2]; x&amp;=0x3F; s2[j]=s[x]; if(s2[j]!=s5[j]){ name[i+2]++; if(name[i+2]&gt;126){ name[i+1]++; name[i+2]=32; } break; } j++; } if(j==32){ break; } } printf(&quot;%s&quot;,name); system(&quot;pause&quot;); return 0; } 运行，得到正确flag]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP连接数据库]]></title>
    <url>%2F2018%2F09%2F16%2FPHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1、mysql_connect()·描述：PHP连接Mysql服务器 ·语法：resource $link = mysql_connect($hostname,$username,$password) ·参数： ·$hostname:域名或IP地址。也可以加端口号 ·$username:用户名，如：root ·$password:密码，如：root ·返回值：成功返回一个资源标识符，失败返回false ·例： 一、 $link = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); 二、 $db_host = &quot;localhost&quot;; $db_user = &quot;root&quot;; $db_pwd = &quot;root&quot;; $link = mysql_connect($db_host,$db_user,$db_pwd); ·注：在函数前面加@,连接失败时不会显示错误信息，防止有用信息泄露 例：$link = @mysql_connect($db_host,$db_user,$db_pwd); 2、exit()·描述：输出一个提示信息，并停止脚本运行 ·语法：void exit([$msg]) ·参数：$msg是可选项，如果省略，只终止脚本运行 ·例：exit(&quot;PHP连接出错&quot;) 3、mysql_error()·描述：返回上一次Mysql执行失败时的文本错误信息，不会显示其他有用信息 ·语法：mysql_error()]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL增删改查]]></title>
    <url>%2F2018%2F09%2F16%2FSQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[添加记录insert into table_name(字段1，字段2，字段3……) values(值1，值2，值3……) 例：insert into news(title,content,hits) values(&apos;title&apos;,&apos;content&apos;,100); 删除记录delete from table_name [where 条件] 注：where如果省略，将删除所有记录 例： delete from news; //删除所有记录 delete from news where id&gt;10; //删除id&gt;10所有记录 delete from news where id&gt;=10 and id!=20; delete from news where author=&apos;admin&apos; and id&lt;100; 修改记录update table_name set 字段1 = 新值1，字段2=新值2，…… [where 条件]; 注：where不能省略，如果省略，所列字段所有记录的值都会一样 例： update news set title =&apos;新标题&apos;,content=&apos;新内容&apos; where id=50; 查询记录select 字段列表/*(所有字段) from table_name [where 条件][order by 字段名 asc(升序)/desc(降序)][limit 限制输出] 例： select * from news where id&lt;50 limit 10,20; 注：输出从第11行开始，id小于50的20条记录]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[整型tinyint 最小型整数 0~255/-128~127 1个字节 smalint 小型整数 0~65535 2个字节 mediumint 中型整数 0~1677万 3个字节 int 一般整数 0~21亿 4个字节 bigint 最大整数 0~42亿 8个字节 浮点型float(M,D) 单精度(精确到小数后7位) double(M,D) 双精度(精确到小数后15位) 注：其中，M代表长度,D代表小数位数 日期和时间data 日期型 格式：&quot;YYYY-mm-dd&quot; time 时间型 格式：&quot;00:00:00&quot; 字符型char(M) 0~255 固定长度字符串 如：身份证、手机号、邮编等 varchar(M) 0~65535 可变长字符串 如：新闻标题、家庭地址等 文本型tinytext 0~255 小型文本 text 0~1670万 中型文本 longtext 0~42亿 大型文本]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据表操作]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[选择数据库：use db_name; 显示当前数据库下的所有数据表（文件）：show tables; 创建数据表：create table table_name(列名1 列的类型 列的属性，列名2 列的类型 列的属性……）; 注：不能以数字开头 列的属性： null | not null：该列是否为空 default default_value:该列的默认值 注：default_value默认值可以是字符串，也可以是整型 auto_increment：该列为自动增长型，或者自动编号，要求该列必须是整型，一个表只能有一个自动增长型 primary key：主键，该列的指具有唯一性，且不能为空，一个表只能有一个主键 id字段属性必须有：not null auto _increment primary key 例：创建一个新闻(news)数据表 create table news( id int not null auto_increment primary key, //编号 title varchar(100) not null, //标题 author varchar(20) not null, //作者 source varchar(30) not null, //来源 hits int(5) not null default 0, //点击次数 is_ppt tinyint(1) not null default 0, //是否是幻灯新闻 content text null, //新闻内容 addate int(16) not null //添加时间 ); 显示字段：describe table_name 删除数据表：drop table [if exists] table_name; 例：drop table news; 修改数据表：alter table]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库操作]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建数据库：create database [if not exists] db_name [charset utf8]; 查看数据库默认字符集：show create database db_name; 删除数据库:drop database [if exists] db_name; 通过命令来修改数据库的字符集：例：alter database db_name default character set utf8; 关于导入sql文件注：导入sql文件时，要先创建数据库，然后再导入数据，且创建的数据库的字符集必须是utf8，否则会乱码]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言空函数转汇编]]></title>
    <url>%2F2018%2F09%2F11%2FC%E8%AF%AD%E8%A8%80%E7%A9%BA%E5%87%BD%E6%95%B0%E8%BD%AC%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[//保存原来栈底 push ebp //提升堆栈 mov ebp,esp sub esp,0x40 //保存现场 push esi push edi push ebx //填充缓存区 mov eax,0xCCCCCCCC mov ecx,0x10 lea edi,dword ptr ds:[ebp-0x40] rep stosd //该函数真正要执行的功能 ...... //恢复现场 pop ebx pop edi pop esi //恢复堆栈 mov esp,ebp pop ebp //返回 ret]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编条件转移指令]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%B1%87%E7%BC%96%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[指令 含义 检测的相关标志位 jcxz cx为0则转移 cx=0 je 等于则转移 zf=1 jne 不等于则转移 zf=0 jb 低于则转移 cf=1 jnb 不低于则转移 cf=0 ja 高于则转移 cf=0且zf=0 jna 不高于则转移 cf=1或zf=1]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[16进制表]]></title>
    <url>%2F2018%2F08%2F15%2F16%E8%BF%9B%E5%88%B6%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[16进制加法表1+1= 2 1+2= 3 | 2+2= 4 1+3= 4 | 2+3= 5 | 3+3= 6 1+4= 5 | 2+4= 6 | 3+4= 7 | 4+4= 8 1+5= 6 | 2+5= 7 | 3+5= 8 | 4+5= 9 | 5+5= A 1+6= 7 | 2+6= 8 | 3+6= 9 | 4+6= A | 5+6= B | 6+6= C 1+7= 8 | 2+7= 9 | 3+7= A | 4+7= B | 5+7= C | 6+7= D | 7+7= E 1+8= 9 | 2+8= A | 3+8= B | 4+8= C | 5+8= D | 6+8= E | 7+8= F | 8+8= 10 1+9= A | 2+9= B | 3+9= C | 4+9= D | 5+9= E | 6+9= F | 7+9= 10 | 8+9= 11 | 9+9= 12 1+A= B | 2+A= C | 3+A= D | 4+A= E | 5+A= F | 6+A= 10 | 7+A= 11 | 8+A= 12 | 9+A= 13 | A+A= 14 1+B= C | 2+B= D | 3+B= E | 4+B= F | 5+B= 10 | 6+B= 11 | 7+B= 12 | 8+B= 13 | 9+B= 14 | A+B= 15 | B+B= 16 1+C= D | 2+C= E | 3+C= F | 4+C= 10 | 5+C= 11 | 6+C= 12 | 7+C= 13 | 8+C= 14 | 9+C= 15 | A+C= 16 | B+C= 17 | C+C= 18 1+D= E | 2+D= F | 3+D= 10 | 4+D= 11 | 5+D= 12 | 6+D= 13 | 7+D= 14 | 8+D= 15 | 9+D= 16 | A+D= 17 | B+D= 18 | C+D= 19 | D+D= 1A 1+E= F | 2+E= 10 | 3+E= 11 | 4+E= 12 | 5+E= 13 | 6+E= 14 | 7+E= 15 | 8+E= 16 | 9+E= 17 | A+E= 18 | B+E= 19 | C+E= 1A | D+E= 1B | E+E= 1C 1+F= 10 | 2+F= 11 | 3+F= 12 | 4+F= 13 | 5+F= 14 | 6+F= 15 | 7+F= 16 | 8+F= 17 | 9+F= 18 | A+F= 19 | B+F= 1A | C+F= 1B | D+F= 1C | E+F= 1D | F+F= 1E 16进制乘法表1*1= 1 1*2= 2 | 2*2= 4 1*3= 3 | 2*3= 6 | 3*3= 9 1*4= 4 | 2*4= 8 | 3*4= C | 4*4= 10 1*5= 5 | 2*5= A | 3*5= F | 4*5= 14 | 5*5= 19 1*6= 6 | 2*6= C | 3*6= 12 | 4*6= 18 | 5*6= 1E | 6*6= 24 1*7= 7 | 2*7= E | 3*7= 15 | 4*7= 1C | 5*7= 23 | 6*7= 2A | 7*7= 31 1*8= 8 | 2*8= 10 | 3*8= 18 | 4*8= 20 | 5*8= 28 | 6*8= 30 | 7*8= 38 | 8*8= 40 1*9= 9 | 2*9= 12 | 3*9= 1B | 4*9= 24 | 5*9= 2D | 6*9= 36 | 7*9= 3F | 8*9= 48 | 9*9= 51 1*A= A | 2*A= 14 | 3*A= 1E | 4*A= 28 | 5*A= 32 | 6*A= 3C | 7*A= 46 | 8*A= 50 | 9*A= 5A | A*A= 64 1*B= B | 2*B= 16 | 3*B= 21 | 4*B= 2C | 5*B= 37 | 6*B= 42 | 7*B= 4D | 8*B= 58 | 9*B= 63 | A*B= 6E | B*B= 79 1*C= C | 2*C= 18 | 3*C= 24 | 4*C= 30 | 5*C= 3C | 6*C= 48 | 7*C= 54 | 8*C= 60 | 9*C= 6C | A*C= 78 | B*C= 84 | C*C= 90 1*D= D | 2*D= 1A | 3*D= 27 | 4*D= 34 | 5*D= 41 | 6*D= 4E | 7*D= 5B | 8*D= 68 | 9*D= 75 | A*D= 82 | B*D= 8F | C*D= 9C | D*D= A9 1*E= E | 2*E= 1C | 3*E= 2A | 4*E= 38 | 5*E= 46 | 6*E= 54 | 7*E= 62 | 8*E= 70 | 9*E= 7E | A*E= 8C | B*E= 9A | C*E= A8 | D*E= B6 | E*E= C4 1*F= F | 2*F= 1E | 3*F= 2D | 4*F= 3C | 5*F= 4B | 6*F= 5A | 7*F= 69 | 8*F= 78 | 9*F= 87 | A*F= 96 | B*F= A5 | C*F= B4 | D*F= C3 | E*F= D2 | F*F= E1]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[atom编辑器的安装与使用]]></title>
    <url>%2F2018%2F05%2F22%2Fatom%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装通过官网源下载最新版 $ sudo wget https://atom.io/download/deb -O atom64.deb $ sudo dpkg -i atom64.deb 这时候在图形界面打开atom会报错解决办法 $ sudo cp /usr/lib/x86_64-linux-gnu/libxcb.so.1 /usr/share/atom/ $ cd /usr/share/atom $ sudo sed -i &apos;s/BIG-REQUESTS/_IG-REQUESTS/&apos; libxcb.so.1]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xterm中文显示]]></title>
    <url>%2F2018%2F05%2F21%2Fxterm%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[在家目录新建文件.Xdefaults $ sudo vi ~/.Xdefaults 加入以下内容 *VT100.font: 9x15 *VT100.utf8Fonts.font: -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1 保存并退出 VNC远程登录，打开终端输入下列命令，让系统加载并生效 # xrdb -merge ~/.Xdefaults 回车 编辑文件的时候就可以正常显示中文啦]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu服务器开启图形界面]]></title>
    <url>%2F2018%2F05%2F21%2Fubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%90%AF%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[开启图形界面1、获取root用户权限 $ sudo su root 2、更新系统软件列表与软件包 # apt-get update # apt-get upgrade 3、安装gnome核心组件 # apt-get install --no-install-recommends ubuntu-desktop gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal -y 4、安装VNC # apt-get install vnc4server 5、配置VNC 输入下面命令，启动VNC,并让它生成一个配置文件。 这里会让你输入一个 连接密码，请记住这个密码。 # vncserver :1 然后输入下面命令，以VNC关闭进程。防止因为文件被占用而修改配置文件时报错。 # vncserver -kill :1 然后输入下面命令，以打开VNC启动配置文件。 # vi ~/.vnc/xstartup 在 &quot;x-window-manager &amp;&quot; 前面添加一个&quot;#&quot;，以注释不再需要的配置。 然后在文件最后加入一段配置信息 gnome-panel &amp; gnome-settings-daemon &amp; metacity &amp; nautilus &amp; 保存并退出（按两次ESC退出编辑模式，输入&quot;:wq&quot;，回车） 6、防火墙配置 打开服务器控制台的防火墙，添加规则 自定义-TCP-5901 重启服务器 VNC配置1、服务器上的配置 先获取root用户权限 $ sudo su root 启动vnc服务 # vncserver :1 回车 2、在本地安装VNC客户端 官网：https://www.realvnc.com/en/connect/download/viewer/ 3、客户端配置 安装好后，在客户端安装目录找到vncviewer，双击打开 在客户端界面的文本框输入&quot;公网IP:1&quot;（引号不用，公网IP就是服务器的IP地址） 输入在服务器配置VNC时设置的密码，OK，就能连接到图形界面了 解决中文乱码问题1、获取root用户权限 $ sudo su root 2、在终端依次输入下列命令 # aptitude install font-manager # aptitude install ttf-arphic-uming # aptitude install ttf-arphic-ukai # aptitude install ttf-wqy-zenhei xfonts-wqy ttf-wqy-microhei # aptitude install fonts-cwtex-fs # aptitude install ttf-hanazono # apt-get install ttf-mscorefonts-installer # mkfontscale # mkfontdir # fc-cache -fv 3、重启VNC服务，即可正常显示中文]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文学摘录]]></title>
    <url>%2F2018%2F05%2F20%2F%E6%96%87%E5%AD%A6%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[《瓦尔登湖》人们所做的邪恶死后还活着。 --莎士比亚《尤科乌斯·凯撒》 我是我眺望的一切景色的君王， 我在那里的权力无可置疑。 --威廉·柯珀 一切悟性都随着清晨苏醒。 --《吠陀经》 坐在精神的世界里驰骋，这是我从书中获得的优势。 一杯美酒即令人沉醉，当喝下深奥的学说的琼浆的时候，我便体验到了这种快乐。 --米尔·卡马尔·乌丁·马斯特 一条恶狗的尾巴可以被烤热，挤压，用带子捆绑起来， 但在让它受了十二年的苦之后，它还将保持其自然的形状。 把世界留给了黑暗，也留给了我。 --托马斯·格雷《墓园挽歌》 哀痛过早地毁灭了悲伤的人； 托斯卡的美丽女儿， 她在这生者的世界里来日无多。 --奥西恩《英雄之爱》 让们到达那里，挤满了小小的房子， 不是为了寻找那里所没有的款待； 休息就是他们的宴会，一切顺其自然， 最高尚的思想有着最大的满足。 --斯宾塞《仙后》 当它说话的时候，它的双翼会时而展开， 好像它要飞翔，却又把双翼合拢起来。 --夸尔斯《牧羊人的神谕》 Nec bella fuerunt, Faginus astabat dum scyphus ante dapes. 当人们需要的只是山毛榉木制的碗的时候， 也就没有战争来骚扰人们。 不要让谋生成为你的工作，而是让你的娱乐成为你的工作； 要享受土地的乐趣，但不要拥有土地。 从未听到被捕的雌鸟说， 猎手们并不是圣徒。 --乔叟《坎特伯雷故事集》 求与梵天合一，则制心克体，行诸善事，必不可弃。 --《吠陀经》]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu搭载网页环境]]></title>
    <url>%2F2018%2F05%2F19%2Fubuntu%E6%90%AD%E8%BD%BD%E7%BD%91%E9%A1%B5%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装Apache1、安装 $ sudo apt-get install apache2 2、查看状态 $ sudo service apache2 restart/status/start/stop 3、关闭防火墙80端口限制 $ sudo ufw allow 80 后面MySQL数据库3306端口也是 4、测试： 访问http://Ubuntu的IP，出现It Works!网页， 安装MySQL1、安装 $ sudo apt-get install mysql-server mysql-client 2、测试 $ sudo mysql -u root -p 3、查看状态 $ sudo service mysql retart/status/start/stop 4、关闭防火墙3306端口限制 $ sudo ufw allow 3306 安装PHP1、安装 $ sudo apt-get install php7.0 $ sudo apt-get install libapache2-mod-php7.0 $ sudo apt-get install php7.0-mysql 2、重启服务 $ sudo service apache2 restart $ sudo service mysql restart 3、测试 $ sudo vim /var/www/html/phpinfo.php 文件中写： &lt;?php echo phpinfo();?&gt; 4、浏览器访问： http:// ubuntu 地址/phpinfo.php 出现PHP Version网页 安装phpMyAdmin1、安装 $ sudo apt-get install phpmyadmin 安装时：空格选择apache2，enter确定，下一步配置数据库，输入密码 2、创建phpMyAdmin快捷方式 $ sudo ln -s /usr/share/phpmyadmin /var/www/html 3、启用Apache mod_rewrite模块，后面修改wordpress链接时会用 $ sudo a2enmod rewrite 4、重启服务 $ sudo service php7.0-fpm restart 提示服务没找到?不去管它 $ sudo service apache2 restart 5、浏览器访问：http:// ubuntu 地址/phpmyadmin 配置Apache1、打开配置文件 $ sudo vim /etc/apache2/apache2.conf 2、添加： $ sudo AddType application/x-httpd-php .php .htm .html $ sudo AddDefaultCharset UTF-8 3、重启Apache服务 $ sudo service apache2 restart 安装ufw 防火墙$ sudo apt-get install ufw]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装VMware-Tools]]></title>
    <url>%2F2018%2F05%2F19%2Fubuntu%E5%AE%89%E8%A3%85VMware-Tools%2F</url>
    <content type="text"><![CDATA[1、加载安装文件如果安装按钮是灰色的，右键虚拟机-设置-软盘 使用物理驱动器：自动检测 就可以安装了 2、拷贝加载后，VMware Tools会加载到桌面 右键，Copy 进入本地home/ 右键空白处，Paste 3、解压打开terminal（终端） 输入 tar -xzvf VMwareTools-xxx-xxx.tar.gz（以实际为准） 回车 4、安装进入解压后的目录 从终端执行安装命令 sudo ./vmware-install.pl 然后一直回车就可以了]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装搜狗拼音输入法]]></title>
    <url>%2F2018%2F05%2F19%2Fubuntu%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、下载文件进入官网http://pinyin.sogou.com/linux，下载自己对应的系统位数安装包 2、打开终端，进入下载目录$ cd Downloads/ (以实际目录为准) 3、安装$ sudo dpkg -i sougoupinyin…….deb (以你下载的实际安装包名字为标准) 4、打开Language Support如果报错，就从终端输入该命令 $ sudo apt-get install -f 成功打开Language Support后，将IBus改为fcitx，然后重启电脑 5、重启后，屏幕右上角会出现键盘图标点击键盘图标，选择Configure Current Input Method 点左下角的 + 取消勾选Only Show Current Language 找到sougou pinyin (一般在最底下)，点ok 6、使用ctrl+空格，切换到搜狗拼音输入法，就可以开始使用啦]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2018%2F05%2F19%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[进入hexo主目录文件夹（假设文件夹名为blog）$ cd blog 常用命令$ sudo hexo new post &quot;文章名&quot; #新建文章 $ sudo hexo g == hexo generate #生成静态页面到public目录 $ sudo hexo s == hexo server #开启本地预览服务 $ sudo hexo s --debug #启动本地预览并调试 $ sudo hexo d == hexo deploy #部署（到github仓库） $ sudo hexo clean #清除缓存 $ sudo hexo generate --watch #监视文件变动 生成静态页面并部署（到github仓库）下面两个命令的作用是相同的 $ sudo hexo g -d == hexo generate --deploy $ sudo hexo d -g == hexo deploy --generate 服务器$ sudo hexo server -s #静态模式 $ sudo hexo server -p xxx #更改端口为xxx端口 $ sudo hexo server -i xxx.xxx.xxx.xxx #自定义 IP 为 xxx.xxx.xxx.xxx]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[github ssh认证]]></title>
    <url>%2F2018%2F05%2F19%2Fgithub-ssh%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、设置Git的user name和email(即在github注册时填写的)$ git config --global user.name &quot;username&quot; $ git config --global user.email &quot;useremail&quot; 2、生成密钥$ sudo ssh-keygen -t rsa -C &quot;username or useremail&quot; 如果出现overwrite(y/n)，默认是n，需要在后面填写y并回车 3、添加密钥到ssh-agent$ eval &quot;$(ssh-agent -s)&quot; Agent pid 59566 4、拷贝ssh进入root用户的ssh目录 $ sudo ~/.ssh 使用 $ sudo cat id_rsa.pub 或 $ sudo vim id_rsa.pub 将里面的内容复制出来 5、将拷贝出来的ssh添加ssh到github登录github，点击右上角头像-settings-SSH and GPG keys 点击New SSH key添加，标题随意 将复制出来的ssh秘钥粘贴进去并保存 6.测试$ sudo ssh -T git@github.com 你将会看到： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 选择 yes Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo到github的推送和拉取]]></title>
    <url>%2F2018%2F05%2F18%2Fhexo%E5%88%B0github%E7%9A%84%E6%8E%A8%E9%80%81%E5%92%8C%E6%8B%89%E5%8F%96%2F</url>
    <content type="text"><![CDATA[推送1、添加当前工作目录文件到index $ sudo git add . 2、生成一个提交文件 $ sudo git commit -a -m &quot;commit first&quot; 3、推送到github的XXX分支 $ sudo git push origin master:XXX 拉取并合并到本地1、清除git缓存 $ sudo git clean -n $ sudo git clean -df $ sudo git clean -f 2、拉取与合并 $ sudo git pull origin 分支名]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nodejs与npm的安装与升级]]></title>
    <url>%2F2018%2F05%2F18%2Fnodejs%E4%B8%8Enpm%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[1、在 Github 上获取 Node.js 源码：$ sudo git clone https://github.com/nodejs/node.git Cloning into &apos;node&apos;... 修改目录权限：$ sudo chmod -R 755 node 进入node目录$ cd node 使用 ./configure 创建编译文件$ sudo ./configure 下一步，可能时间有点长，耐心等待$ sudo make 最后$ sudo make install 查看版本$ node -v v0.10.25 2、安装最新版npm$ sudo npm install npm@latest -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu hexo博客搭建详细步骤]]></title>
    <url>%2F2018%2F05%2F18%2Fubuntu%20hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[安装nodejs$ sudo apt-get install nodejs 安装git$ sudo apt-get install git Github需要有github帐号，然后在github上新建一个仓库，一定要命名为username.github.io 进行git ssh 认证，参考https://segmentfault.com/a/1190000002645623 安装nodejs,然后使用npm安装hexo$ npm install -g hexo 注：这时候可能会报错，需要先更新nodejs与npm版本 创建博客文件夹$ hexo init 文件夹的名字(假设为BLOG) 进入博客文件夹 $ cd BLOG $ npm install //安装依赖 git配置$ cd BLOG $ git config --global user.name &quot;username&quot; // username为你自己的github用户名 $ git config --global user.email &quot;email@example.com&quot; 关联远程仓库$ git remote add origin &quot;仓库url&quot; 修改配置文件 修改BLOG目录下的_config.yml里面底部的Deployment部分为 deploy: type: git repo: git@github.com:username/username.github.io.git branch: master]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu更新源]]></title>
    <url>%2F2018%2F05%2F18%2Fubuntu%E6%9B%B4%E6%96%B0%E6%BA%90%2F</url>
    <content type="text"><![CDATA[1、在修改source.list前，最好先备份一份执行备份命令 $ sudo cp /etc/apt/sources.list /etc/apt/sources.list.old 2、执行命令打开source.list文件：$ sudo vim /etc/apt/source.list 3、用新的源覆盖文件里的内容按i开启编辑模式， 以下为清华大学源，复制进去即可 # deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse 按esc退出编辑模式，输入:wq保存并退出（冒号也需要输入） 4、执行更新命令$ sudo apt-get update &amp;&amp; apt-get upgrade &amp;&amp;apt-get dist-upgrade]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网址收藏]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[字体库：font.chinaz.com shufazidian.com 图库：www.pexels.com www.pixabay.com www.stocksnap.com www.librestock.com 无白底：pngimg.com 图片放大：bigjpg.com 图标：www.51yuansu.com www.easyicon.net www.iconfont.cn 动作图标：pictogram2.com]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
